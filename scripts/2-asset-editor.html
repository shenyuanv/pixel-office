<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Asset Editor - 3 Pane Resizable</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { background: #1a1a2e; color: #e0e0e0; font-family: 'Segoe UI', system-ui, sans-serif; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }

    /* Main toolbar (top) */
    #main-toolbar { padding: 8px 12px; background: #16213e; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; border-bottom: 1px solid #333; }
    #main-toolbar label { font-size: 12px; color: #aaa; }
    #main-toolbar select, #main-toolbar input, #main-toolbar button { font-size: 12px; padding: 3px 8px; border-radius: 3px; border: 1px solid #555; background: #2a2a4a; color: #e0e0e0; cursor: pointer; }
    #main-toolbar button { background: #0f3460; border-color: #1a5276; }
    #main-toolbar button:hover { background: #1a5276; }
    #main-toolbar button.primary { background: #27ae60; border-color: #2ecc71; }
    #main-toolbar button.primary:hover { background: #2ecc71; }
    #main-toolbar button.active { background: #00ff00; border-color: #00ff00; color: #000; font-weight: bold; }
    .sep { width: 1px; height: 20px; background: #444; display: inline-block; }

    /* Control toolbar (below main toolbar) */
    #control-toolbar { padding: 6px 12px; background: #0f3460; display: flex; gap: 12px; align-items: center; flex-wrap: wrap; border-bottom: 1px solid #333; font-size: 11px; }
    .control-group { display: flex; gap: 6px; align-items: center; }
    .control-group label { color: #aaa; }
    .control-group input { padding: 2px 6px; background: #2a2a4a; border: 1px solid #555; color: #e0e0e0; border-radius: 2px; font-size: 11px; width: 50px; }
    .control-group button { padding: 3px 8px; background: #1a5276; border: 1px solid #3498db; color: #e0e0e0; border-radius: 2px; cursor: pointer; font-size: 11px; }
    .control-group button:hover { background: #3498db; }
    .control-group button.danger { background: #6b2020; border-color: #8b3030; }
    .control-group button.danger:hover { background: #8b3030; }
    .control-group button.primary { background: #27ae60; border-color: #2ecc71; }
    .control-group button.primary:hover { background: #2ecc71; }

    /* Main content area */
    #content { flex: 1; display: flex; gap: 0; min-height: 0; overflow: hidden; }

    /* Left: Asset list */
    #left-pane { width: 200px; display: flex; flex-direction: column; background: #16213e; border-right: 2px solid #444; min-width: 100px; }
    #left-pane h3 { padding: 8px 12px; font-size: 13px; border-bottom: 1px solid #333; background: #0f3460; flex-shrink: 0; }
    #asset-list { flex: 1; overflow-y: auto; padding: 4px; }
    .asset-entry {
      padding: 4px; margin: 2px 0; border-radius: 4px; font-size: 10px;
      background: #1a1a3e; border: 1px solid #333; cursor: pointer; display: flex; gap: 4px; align-items: flex-start;
    }
    .asset-entry:hover { border-color: #555; }
    .asset-entry.selected { border-color: #3498db; background: #1a2a4e; }
    .asset-thumb { flex-shrink: 0; image-rendering: pixelated; background: #000; border: 1px solid #555; border-radius: 2px; }
    .asset-info { flex: 1; min-width: 0; }
    .asset-name { font-weight: 600; color: #eee; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .asset-dims { color: #888; font-size: 9px; margin-top: 1px; }
    .asset-status { display: inline-block; padding: 1px 4px; border-radius: 2px; font-size: 8px; margin-top: 2px; }
    .status-ok { background: #27ae60; color: #fff; }
    .status-split { background: #f39c12; color: #fff; }
    .status-discard { background: #e74c3c; color: #fff; }

    /* Resize handle */
    .resize-handle { width: 4px; background: #444; cursor: col-resize; user-select: none; }
    .resize-handle:hover { background: #3498db; }

    /* Middle: Preview */
    #middle-pane { flex: 1; display: flex; flex-direction: column; background: #1a1a2e; border-right: 2px solid #444; min-width: 200px; }
    #middle-pane h3 { padding: 8px 12px; font-size: 12px; border-bottom: 1px solid #333; background: #0f3460; flex-shrink: 0; }
    #preview-container { flex: 1; display: flex; align-items: center; justify-content: center; padding: 12px; overflow: auto; }
    #asset-preview { image-rendering: pixelated; max-width: 100%; max-height: 100%; border: 2px solid #555; background: #000; }

    /* Right: Tileset */
    #right-pane { flex: 1; display: flex; flex-direction: column; background: #1a1a2e; min-width: 200px; }
    #right-pane h3 { padding: 8px 12px; font-size: 12px; border-bottom: 1px solid #333; background: #0f3460; flex-shrink: 0; }
    #canvas-wrap { flex: 1; overflow: auto; background: #111; }
    #tileset-canvas { display: block; image-rendering: pixelated; cursor: crosshair; }

    /* Status bar */
    #status { padding: 4px 12px; background: #0f3460; font-size: 11px; color: #888; border-top: 1px solid #333; flex-shrink: 0; }
  </style>
</head>
<body>

<!-- Main toolbar (top) -->
<div id="main-toolbar">
  <button id="btn-load-tileset">Load Tileset PNG</button>
  <button id="btn-load-json">Load Detection JSON</button>
  <button id="btn-load-saved" style="background:#f39c12; border-color:#f5ab35">Load Saved Progress</button>
  <span class="sep"></span>

  <label>Preview Zoom:</label>
  <select id="preview-zoom">
    <option value="1">1x</option>
    <option value="2" selected>2x</option>
    <option value="3">3x</option>
    <option value="4">4x</option>
    <option value="6">6x</option>
  </select>

  <label>Tileset Zoom:</label>
  <select id="tileset-zoom">
    <option value="1">1x</option>
    <option value="2" selected>2x</option>
    <option value="3">3x</option>
  </select>

  <label><input type="checkbox" id="show-ids" checked> Show IDs</label>
  <span class="sep"></span>

  <button id="btn-split-v">â¬‡ Vertical Split</button>
  <button id="btn-split-h">â¬‡ Horizontal Split</button>
  <button id="btn-clear-splits" style="background:#6b2020; border-color:#8b3030">Clear Splits</button>

  <button id="btn-eraser">ğŸ”´ Pixel Eraser</button>
  <button id="btn-clear-erased" style="background:#6b2020; border-color:#8b3030">Clear Erased</button>

  <span class="sep"></span>
  <button class="primary" id="btn-export">Export Approved</button>
</div>

<!-- Control toolbar -->
<div id="control-toolbar">
  <div class="control-group">
    <label>Padded Position & Size:</label>
    <label>X:</label>
    <input id="ctrl-x" type="number" min="-512" placeholder="X">
    <label>Y:</label>
    <input id="ctrl-y" type="number" min="-512" placeholder="Y">
    <label>W:</label>
    <input id="ctrl-w" type="number" min="1" placeholder="W">
    <label>H:</label>
    <input id="ctrl-h" type="number" min="1" placeholder="H">
  </div>

  <div class="control-group">
    <button id="btn-reset" style="background:#4a4a6a; border-color:#666;">Reset to Orig</button>
    <button id="btn-discard" class="danger">Discard</button>
    <button id="btn-apply-splits" class="primary">Apply Splits</button>
  </div>

  <div class="control-group" style="margin-left: auto;">
    <span id="splits-info" style="color:#aaa;">0 splits</span>
  </div>
</div>

<!-- Main content (3 panes) -->
<div id="content">
  <!-- Left: Asset list -->
  <div id="left-pane">
    <h3>Assets (<span id="asset-count">0</span>)</h3>
    <div id="asset-list"></div>
  </div>

  <div class="resize-handle" id="handle-1"></div>

  <!-- Middle: Preview -->
  <div id="middle-pane">
    <h3>Preview</h3>
    <div id="preview-container">
      <canvas id="asset-preview" width="400" height="300"></canvas>
    </div>
  </div>

  <div class="resize-handle" id="handle-2"></div>

  <!-- Right: Tileset -->
  <div id="right-pane">
    <h3>Tileset View</h3>
    <div id="canvas-wrap">
      <canvas id="tileset-canvas"></canvas>
    </div>
  </div>
</div>

<!-- Status bar -->
<div id="status">Ready</div>

<input type="file" id="tileset-file" accept="image/png" style="display:none">
<input type="file" id="json-file" accept="application/json" style="display:none">
<input type="file" id="saved-file" accept="application/json" style="display:none">

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let img = null
let detectionData = null
let previewZoom = 2
let tilesetZoom = 2
let selectedIdx = -1
let showIds = true
let splitTool = null // 'vertical' or 'horizontal'
let splits = [] // Array of { axis: 'v' | 'h', position: number }
let eraserTool = false // Whether eraser is active
let eraserSize = 1 // Size of eraser brush in pixels
let isErasingDrag = false // Track if user is dragging with eraser

const previewCanvas = document.getElementById('asset-preview')
const previewCtx = previewCanvas.getContext('2d')
const tilesetCanvas = document.getElementById('tileset-canvas')
const tilesetCtx = tilesetCanvas.getContext('2d')
const assetList = document.getElementById('asset-list')
const assetCount = document.getElementById('asset-count')
const status = document.getElementById('status')
const splitsInfo = document.getElementById('splits-info')

const leftPane = document.getElementById('left-pane')
const middlePane = document.getElementById('middle-pane')
const rightPane = document.getElementById('right-pane')
const handle1 = document.getElementById('handle-1')
const handle2 = document.getElementById('handle-2')

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RESIZABLE PANES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let isResizing = null

handle1.onmousedown = () => { isResizing = 1 }
handle2.onmousedown = () => { isResizing = 2 }

document.onmousemove = (e) => {
  if (!isResizing) return

  const content = document.getElementById('content')
  const rect = content.getBoundingClientRect()
  const x = e.clientX - rect.left

  if (isResizing === 1) {
    const newLeftWidth = Math.max(100, Math.min(x, rect.width - 300))
    leftPane.style.width = newLeftWidth + 'px'
  } else if (isResizing === 2) {
    const leftWidth = leftPane.offsetWidth
    const handle1Width = 4
    const newMiddleWidth = Math.max(200, Math.min(x - leftWidth - handle1Width, rect.width - leftWidth - handle1Width - 200))
    middlePane.style.flex = 'none'
    middlePane.style.width = newMiddleWidth + 'px'
  }
}

document.onmouseup = () => { isResizing = null }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FILE LOADING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

document.getElementById('btn-load-tileset').onclick = () => document.getElementById('tileset-file').click()
document.getElementById('tileset-file').onchange = (e) => {
  const file = e.target.files[0]
  if (!file) return
  const reader = new FileReader()
  reader.onload = (ev) => {
    const i = new Image()
    i.onload = () => {
      img = i
      renderTileset()
      status.textContent = `Tileset loaded: ${i.width}x${i.height}px`
      if (selectedIdx >= 0) renderPreview()
    }
    i.src = ev.target.result
  }
  reader.readAsDataURL(file)
}

document.getElementById('btn-load-json').onclick = () => document.getElementById('json-file').click()
document.getElementById('json-file').onchange = (e) => {
  const file = e.target.files[0]
  if (!file) return
  const reader = new FileReader()
  reader.onload = (ev) => {
    try {
      detectionData = JSON.parse(ev.target.result)
      selectedIdx = 0
      renderAssetList()
      renderTileset()
      renderPreview()
      status.textContent = `Detected: ${detectionData.assets.length} assets`
    } catch (err) {
      alert('Invalid JSON: ' + err.message)
    }
  }
  reader.readAsText(file)
}

document.getElementById('btn-load-saved').onclick = () => document.getElementById('saved-file').click()
document.getElementById('saved-file').onchange = (e) => {
  const file = e.target.files[0]
  if (!file) return
  const reader = new FileReader()
  reader.onload = (ev) => {
    try {
      const savedData = JSON.parse(ev.target.result)
      detectionData = savedData
      selectedIdx = 0
      splits = []
      splitTool = null
      renderAssetList()
      renderTileset()
      renderPreview()
      updateSplitsInfo()
      status.textContent = `Loaded: ${detectionData.assets.length} assets (approved)`
    } catch (err) {
      alert('Invalid JSON: ' + err.message)
    }
  }
  reader.readAsText(file)
}

// Try to auto-load from localStorage
window.addEventListener('load', () => {
  try {
    const saved = localStorage.getItem('asset-editor-data')
    if (saved) {
      detectionData = JSON.parse(saved)
      selectedIdx = 0
      renderAssetList()
      renderTileset()
      renderPreview()
    }
  } catch {}
})

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CONTROLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

document.getElementById('preview-zoom').onchange = (e) => { previewZoom = +e.target.value; renderPreview() }
document.getElementById('tileset-zoom').onchange = (e) => { tilesetZoom = +e.target.value; renderTileset() }
document.getElementById('show-ids').onchange = (e) => { showIds = e.target.checked; renderTileset() }

// Real-time input updates
['ctrl-x', 'ctrl-y', 'ctrl-w', 'ctrl-h'].forEach(id => {
  document.getElementById(id).oninput = () => {
    if (selectedIdx >= 0) {
      detectionData.assets[selectedIdx].paddedX = +document.getElementById('ctrl-x').value
      detectionData.assets[selectedIdx].paddedY = +document.getElementById('ctrl-y').value
      detectionData.assets[selectedIdx].paddedWidth = +document.getElementById('ctrl-w').value
      detectionData.assets[selectedIdx].paddedHeight = +document.getElementById('ctrl-h').value
      renderPreview()
      renderTileset()
      saveData()
    }
  }
})

// Split tools
document.getElementById('btn-split-v').onclick = () => {
  splitTool = splitTool === 'vertical' ? null : 'vertical'
  document.getElementById('btn-split-v').classList.toggle('active')
  document.getElementById('btn-split-h').classList.remove('active')
}

document.getElementById('btn-split-h').onclick = () => {
  splitTool = splitTool === 'horizontal' ? null : 'horizontal'
  document.getElementById('btn-split-h').classList.toggle('active')
  document.getElementById('btn-split-v').classList.remove('active')
}

document.getElementById('btn-clear-splits').onclick = () => {
  splits = []
  updateSplitsInfo()
  renderPreview()
}

// Eraser tool
document.getElementById('btn-eraser').onclick = () => {
  eraserTool = !eraserTool
  document.getElementById('btn-eraser').classList.toggle('active')
  document.getElementById('btn-split-v').classList.remove('active')
  document.getElementById('btn-split-h').classList.remove('active')
  splitTool = null
}

document.getElementById('btn-clear-erased').onclick = () => {
  if (selectedIdx < 0 || !detectionData) return
  const asset = detectionData.assets[selectedIdx]
  asset.erasedPixels = []
  renderPreview()
  saveData()
}

document.getElementById('btn-reset').onclick = () => {
  if (selectedIdx < 0 || !detectionData) return
  const asset = detectionData.assets[selectedIdx]
  asset.paddedX = Math.max(0, asset.paddedX)
  asset.paddedY = Math.max(0, asset.paddedY)
  renderAssetList()
  renderTileset()
  renderPreview()
  updateControls()
  saveData()
}

document.getElementById('btn-discard').onclick = () => {
  if (selectedIdx < 0 || !detectionData) return
  const asset = detectionData.assets[selectedIdx]
  asset.discard = !asset.discard
  renderAssetList()
  renderTileset()
  updateControlButton()
  saveData()
}

document.getElementById('btn-apply-splits').onclick = () => {
  if (selectedIdx < 0 || !detectionData || splits.length === 0) {
    alert('Select an asset and draw at least one split')
    return
  }

  const asset = detectionData.assets[selectedIdx]
  const vsplits = splits.filter(s => s.axis === 'v').map(s => s.position).sort((a, b) => a - b)
  const hsplits = splits.filter(s => s.axis === 'h').map(s => s.position).sort((a, b) => a - b)

  // Generate segments from splits
  let rows = [{ y: 0, h: asset.paddedHeight }]
  for (const y of hsplits) {
    const newRows = []
    for (const row of rows) {
      if (y > row.y && y < row.y + row.h) {
        newRows.push({ y: row.y, h: y - row.y })
        newRows.push({ y, h: row.y + row.h - y })
      } else {
        newRows.push(row)
      }
    }
    rows = newRows
  }

  let cols = [{ x: 0, w: asset.paddedWidth }]
  for (const x of vsplits) {
    const newCols = []
    for (const col of cols) {
      if (x > col.x && x < col.x + col.w) {
        newCols.push({ x: col.x, w: x - col.x })
        newCols.push({ x, w: col.x + col.w - x })
      } else {
        newCols.push(col)
      }
    }
    cols = newCols
  }

  // Create new assets from all segments
  const newAssets = []
  for (let ri = 0; ri < rows.length; ri++) {
    for (let ci = 0; ci < cols.length; ci++) {
      const row = rows[ri]
      const col = cols[ci]

      // Filter erased pixels to only those within this segment
      const segmentErased = []
      if (asset.erasedPixels) {
        for (const pixel of asset.erasedPixels) {
          if (
            pixel.x >= col.x &&
            pixel.x < col.x + col.w &&
            pixel.y >= row.y &&
            pixel.y < row.y + row.h
          ) {
            segmentErased.push({
              x: pixel.x - col.x,
              y: pixel.y - row.y,
            })
          }
        }
      }

      newAssets.push({
        ...asset,
        id: `${asset.id}_${ri}_${ci}`,
        paddedX: asset.paddedX + col.x,
        paddedY: asset.paddedY + row.y,
        paddedWidth: col.w,
        paddedHeight: row.h,
        erasedPixels: segmentErased.length > 0 ? segmentErased : undefined,
        splitMarker: true,
      })
    }
  }

  // Replace the original asset with split versions
  detectionData.assets.splice(selectedIdx, 1, ...newAssets)

  splits = []
  splitTool = null
  selectedIdx = -1
  document.getElementById('btn-split-v').classList.remove('active')
  document.getElementById('btn-split-h').classList.remove('active')
  updateSplitsInfo()
  renderAssetList()
  renderTileset()
  renderPreview()
  saveData()
}

document.getElementById('btn-export').onclick = () => {
  if (!detectionData) return
  const approved = detectionData.assets.filter(a => !a.discard)
  const output = { ...detectionData, assets: approved }
  const json = JSON.stringify(output, null, 2)
  const blob = new Blob([json], { type: 'application/json' })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  a.download = 'asset-editor-output.json'
  a.click()
  URL.revokeObjectURL(url)
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SPLIT TOOLS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Helper: Get pixel coordinates from mouse event
function getPixelCoords(e) {
  const rect = previewCanvas.getBoundingClientRect()
  const x = e.clientX - rect.left
  const y = e.clientY - rect.top
  const px = Math.floor(x / previewZoom)
  const py = Math.floor(y / previewZoom)
  return { px, py, x, y }
}

// Helper: Toggle pixel in erased list (add if not present, remove if present)
function toggleErasedPixel(asset, px, py) {
  if (!asset.erasedPixels) asset.erasedPixels = []
  const key = `${px},${py}`
  const idx = asset.erasedPixels.findIndex(p => `${p.x},${p.y}` === key)
  if (idx >= 0) {
    asset.erasedPixels.splice(idx, 1)
  } else {
    asset.erasedPixels.push({ x: px, y: py })
  }
}

// Helper: Bresenham line algorithm to get all pixels between two points
function getPixelLine(x0, y0, x1, y1) {
  const pixels = []
  const dx = Math.abs(x1 - x0)
  const dy = Math.abs(y1 - y0)
  const sx = x0 < x1 ? 1 : -1
  const sy = y0 < y1 ? 1 : -1
  let err = dx - dy

  let x = x0
  let y = y0

  while (true) {
    pixels.push({ x, y })
    if (x === x1 && y === y1) break
    const e2 = 2 * err
    if (e2 > -dy) {
      err -= dy
      x += sx
    }
    if (e2 < dx) {
      err += dx
      y += sy
    }
  }

  return pixels
}

// Mouse down: Start erasing drag or handle split tools
previewCanvas.onmousedown = (e) => {
  if (selectedIdx < 0 || !detectionData) return

  const coords = getPixelCoords(e)
  const asset = detectionData.assets[selectedIdx]

  // Eraser tool drag
  if (eraserTool) {
    isErasingDrag = true
    return
  }

  // Split tools (single click)
  if (splitTool === 'vertical') {
    const position = Math.round(coords.x / previewZoom)
    if (position > 0 && position < asset.paddedWidth) {
      splits.push({ axis: 'v', position })
      splits = splits.sort((a, b) => a.position - b.position)
      updateSplitsInfo()
      renderPreview()
    }
  } else if (splitTool === 'horizontal') {
    const position = Math.round(coords.y / previewZoom)
    if (position > 0 && position < asset.paddedHeight) {
      splits.push({ axis: 'h', position })
      splits = splits.sort((a, b) => a.position - b.position)
      updateSplitsInfo()
      renderPreview()
    }
  }
}

// Mouse move: Handle eraser drag
previewCanvas.onmousemove = (e) => {
  if (!eraserTool || selectedIdx < 0) {
    previewCanvas.style.cursor = splitTool ? 'crosshair' : 'default'
    return
  }

  previewCanvas.style.cursor = 'pointer'

  if (!isErasingDrag) return

  const coords = getPixelCoords(e)
  const asset = detectionData.assets[selectedIdx]

  // Get the last erased position (or current if starting)
  let lastPx = coords.px
  let lastPy = coords.py

  // Get erased pixels array
  if (!asset.erasedPixels) asset.erasedPixels = []
  const lastErased = asset.erasedPixels[asset.erasedPixels.length - 1]
  if (lastErased) {
    lastPx = lastErased.x
    lastPy = lastErased.y
  }

  // Get all pixels along the line from last position to current
  const line = getPixelLine(lastPx, lastPy, coords.px, coords.py)

  // Add all pixels along the line (avoid duplicates)
  for (const pixel of line) {
    if (
      pixel.x >= 0 &&
      pixel.x < asset.paddedWidth &&
      pixel.y >= 0 &&
      pixel.y < asset.paddedHeight
    ) {
      const key = `${pixel.x},${pixel.y}`
      const exists = asset.erasedPixels.some(p => `${p.x},${p.y}` === key)
      if (!exists) {
        asset.erasedPixels.push({ x: pixel.x, y: pixel.y })
      }
    }
  }

  renderPreview()
}

// Mouse up: End eraser drag
previewCanvas.onmouseup = () => {
  if (isErasingDrag) {
    isErasingDrag = false
    saveData()
  }
}

// Leave canvas: End eraser drag
previewCanvas.onmouseleave = () => {
  if (isErasingDrag) {
    isErasingDrag = false
    saveData()
  }
}

function updateSplitsInfo() {
  const vsplits = splits.filter(s => s.axis === 'v').length
  const hsplits = splits.filter(s => s.axis === 'h').length
  splitsInfo.textContent = `${splits.length} splits (${vsplits}v, ${hsplits}h)`
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// RENDERING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function renderPreview() {
  if (!detectionData || selectedIdx < 0 || selectedIdx >= detectionData.assets.length) return
  if (!img) return

  const asset = detectionData.assets[selectedIdx]

  const w = asset.paddedWidth * previewZoom
  const h = asset.paddedHeight * previewZoom
  previewCanvas.width = w
  previewCanvas.height = h
  previewCtx.imageSmoothingEnabled = false

  previewCtx.clearRect(0, 0, w, h)

  // Draw portion of tileset
  const srcX = Math.max(0, asset.paddedX)
  const srcY = Math.max(0, asset.paddedY)
  const srcW = asset.paddedWidth - (Math.max(0, -asset.paddedX))
  const srcH = asset.paddedHeight - (Math.max(0, -asset.paddedY))
  const dstX = Math.max(0, -asset.paddedX) * previewZoom
  const dstY = Math.max(0, -asset.paddedY) * previewZoom

  if (srcW > 0 && srcH > 0 && srcX < img.width && srcY < img.height) {
    previewCtx.drawImage(
      img,
      srcX, srcY, Math.min(srcW, img.width - srcX), Math.min(srcH, img.height - srcY),
      dstX, dstY, Math.min(srcW, img.width - srcX) * previewZoom, Math.min(srcH, img.height - srcY) * previewZoom
    )
  }

  // Draw 16px grid
  previewCtx.strokeStyle = 'rgba(255,255,255,0.2)'
  previewCtx.lineWidth = 1
  for (let x = 0; x <= w; x += 16 * previewZoom) {
    previewCtx.beginPath()
    previewCtx.moveTo(x, 0)
    previewCtx.lineTo(x, h)
    previewCtx.stroke()
  }
  for (let y = 0; y <= h; y += 16 * previewZoom) {
    previewCtx.beginPath()
    previewCtx.moveTo(0, y)
    previewCtx.lineTo(w, y)
    previewCtx.stroke()
  }

  // Draw erased pixels as red overlay
  if (asset.erasedPixels && asset.erasedPixels.length > 0) {
    previewCtx.fillStyle = 'rgba(255, 0, 0, 0.4)'
    for (const pixel of asset.erasedPixels) {
      const px = pixel.x * previewZoom
      const py = pixel.y * previewZoom
      previewCtx.fillRect(px, py, previewZoom, previewZoom)
    }
  }

  // Draw split lines in bright green
  previewCtx.strokeStyle = '#00ff00'
  previewCtx.lineWidth = 2
  for (const split of splits) {
    if (split.axis === 'v') {
      const x = split.position * previewZoom
      previewCtx.beginPath()
      previewCtx.moveTo(x, 0)
      previewCtx.lineTo(x, h)
      previewCtx.stroke()
    } else {
      const y = split.position * previewZoom
      previewCtx.beginPath()
      previewCtx.moveTo(0, y)
      previewCtx.lineTo(w, y)
      previewCtx.stroke()
    }
  }

  // Border
  previewCtx.strokeStyle = '#3498db'
  previewCtx.lineWidth = 2
  previewCtx.strokeRect(0, 0, w, h)
}

function renderTileset() {
  if (!img || !detectionData) return

  tilesetCanvas.width = img.width * tilesetZoom
  tilesetCanvas.height = img.height * tilesetZoom
  tilesetCtx.imageSmoothingEnabled = false
  tilesetCtx.clearRect(0, 0, tilesetCanvas.width, tilesetCanvas.height)

  tilesetCtx.drawImage(img, 0, 0, tilesetCanvas.width, tilesetCanvas.height)

  detectionData.assets.forEach((asset, idx) => {
    const isSelected = idx === selectedIdx
    const isDiscarded = asset.discard

    const x = asset.paddedX * tilesetZoom
    const y = asset.paddedY * tilesetZoom
    const w = asset.paddedWidth * tilesetZoom
    const h = asset.paddedHeight * tilesetZoom

    tilesetCtx.strokeStyle = isDiscarded ? '#e74c3c' : isSelected ? '#3498db' : '#2ecc71'
    tilesetCtx.lineWidth = isSelected ? 3 : 2
    tilesetCtx.strokeRect(x, y, w, h)

    if (showIds) {
      const px = x + 2
      const py = y + 12
      tilesetCtx.font = `bold ${Math.max(8, tilesetZoom * 2)}px monospace`
      tilesetCtx.fillStyle = 'rgba(0,0,0,0.5)'
      const textW = tilesetCtx.measureText(asset.id).width
      tilesetCtx.fillRect(px - 1, py - 10, textW + 4, tilesetZoom * 3 + 2)
      tilesetCtx.fillStyle = isDiscarded ? '#e74c3c' : '#2ecc71'
      tilesetCtx.fillText(asset.id, px + 2, py)
    }
  })
}

function renderAssetList() {
  if (!detectionData) return

  assetCount.textContent = detectionData.assets.filter(a => !a.discard).length + ' / ' + detectionData.assets.length

  assetList.innerHTML = ''
  detectionData.assets.forEach((asset, idx) => {
    const div = document.createElement('div')
    div.className = 'asset-entry' + (idx === selectedIdx ? ' selected' : '')
    div.onclick = () => {
      selectedIdx = idx
      splits = []
      splitTool = null
      eraserTool = false
      document.getElementById('btn-split-v').classList.remove('active')
      document.getElementById('btn-split-h').classList.remove('active')
      document.getElementById('btn-eraser').classList.remove('active')
      updateSplitsInfo()
      renderAssetList()
      updateControls()
      renderPreview()
      renderTileset()
    }

    // Thumbnail canvas
    const thumb = document.createElement('canvas')
    const sz = 48
    thumb.width = sz
    thumb.height = sz
    thumb.className = 'asset-thumb'
    if (img) {
      const tctx = thumb.getContext('2d')
      tctx.imageSmoothingEnabled = false
      const srcX = asset.paddedX
      const srcY = asset.paddedY
      const srcW = asset.paddedWidth
      const srcH = asset.paddedHeight
      const scale = Math.min(sz / srcW, sz / srcH)
      const dw = srcW * scale
      const dh = srcH * scale
      tctx.drawImage(
        img,
        srcX, srcY, srcW, srcH,
        (sz - dw) / 2, (sz - dh) / 2, dw, dh
      )

      // Draw erased pixels as semi-transparent red on thumbnail
      if (asset.erasedPixels && asset.erasedPixels.length > 0) {
        tctx.fillStyle = 'rgba(255, 0, 0, 0.3)'
        for (const pixel of asset.erasedPixels) {
          const px = (pixel.x * scale) + (sz - dw) / 2
          const py = (pixel.y * scale) + (sz - dh) / 2
          tctx.fillRect(px, py, Math.max(1, scale), Math.max(1, scale))
        }
      }
    }
    div.appendChild(thumb)

    const info = document.createElement('div')
    info.className = 'asset-info'
    const status = asset.discard ? 'DISCARD' : asset.splitMarker ? 'SPLIT' : 'OK'
    const statusClass = asset.discard ? 'status-discard' : asset.splitMarker ? 'status-split' : 'status-ok'
    info.innerHTML = `
      <div class="asset-name">${asset.id}</div>
      <div class="asset-dims">${asset.paddedWidth}Ã—${asset.paddedHeight}</div>
      <span class="asset-status ${statusClass}">${status}</span>
    `
    div.appendChild(info)
    assetList.appendChild(div)
  })

  if (selectedIdx >= 0 && selectedIdx < assetList.children.length) {
    assetList.children[selectedIdx].scrollIntoView({ block: 'nearest' })
  }
}

function updateControls() {
  if (selectedIdx < 0 || !detectionData) return
  const asset = detectionData.assets[selectedIdx]
  document.getElementById('ctrl-x').value = asset.paddedX
  document.getElementById('ctrl-y').value = asset.paddedY
  document.getElementById('ctrl-w').value = asset.paddedWidth
  document.getElementById('ctrl-h').value = asset.paddedHeight
  updateControlButton()
}

function updateControlButton() {
  const btn = document.getElementById('btn-discard')
  if (selectedIdx >= 0 && detectionData) {
    btn.textContent = detectionData.assets[selectedIdx].discard ? 'Undo Discard' : 'Discard'
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PERSISTENCE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function saveData() {
  if (detectionData) {
    try {
      localStorage.setItem('asset-editor-data', JSON.stringify(detectionData))
    } catch {}
  }
}

setInterval(saveData, 2000)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// KEYBOARD
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

document.onkeydown = (e) => {
  if (e.target.tagName === 'INPUT') return

  if (e.key === 'ArrowUp' && selectedIdx > 0) {
    selectedIdx--
    renderAssetList()
    updateControls()
    renderPreview()
    renderTileset()
  } else if (e.key === 'ArrowDown' && selectedIdx < detectionData.assets.length - 1) {
    selectedIdx++
    renderAssetList()
    updateControls()
    renderPreview()
    renderTileset()
  } else if (e.key === 'Delete' || e.key === 'Backspace') {
    if (selectedIdx >= 0) {
      document.getElementById('btn-discard').click()
    }
  } else if (e.key === 'Escape') {
    selectedIdx = -1
    renderAssetList()
    renderPreview()
  }
}
</script>
</body>
</html>
